diff --git a/fs/Kconfig b/fs/Kconfig
index 2c756044e883..0c9e83023d0f 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -387,4 +387,11 @@ source "fs/unicode/Kconfig"
 config IO_WQ
 	bool
 
+config NOMOUNT
+	bool "NoMount Path Redirection Subsystem"
+	default y
+	help
+	  NoMount allows path redirection and virtual file injection
+	  without mounting filesystems. Useful for systemless modifications.
+
 endmenu
diff --git a/fs/Makefile b/fs/Makefile
index e4adb988218c..47dff00c953a 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -139,3 +139,4 @@ obj-$(CONFIG_EFIVAR_FS)		+= efivarfs/
 obj-$(CONFIG_EROFS_FS)		+= erofs/
 obj-$(CONFIG_VBOXSF_FS)		+= vboxsf/
 obj-$(CONFIG_ZONEFS_FS)		+= zonefs/
+obj-$(CONFIG_NOMOUNT) += nomount.o
diff --git a/fs/d_path.c b/fs/d_path.c
index cd60c7535181..1915232ff77d 100644
--- a/fs/d_path.c
+++ b/fs/d_path.c
@@ -8,6 +8,10 @@
 #include <linux/prefetch.h>
 #include "mount.h"
 
+#ifdef CONFIG_NOMOUNT
+#include <linux/nomount.h>
+#endif
+
 struct prepend_buffer {
 	char *buf;
 	int len;
@@ -268,6 +272,25 @@ char *d_path(const struct path *path, char *buf, int buflen)
 	DECLARE_BUFFER(b, buf, buflen);
 	struct path root;
 
+#ifdef CONFIG_NOMOUNT
+    if (path->dentry && path->dentry->d_inode) {
+        char *v_path = nomount_get_virtual_path_for_inode(path->dentry->d_inode);
+        
+        if (v_path) {
+            int len = strlen(v_path);
+            if (buflen < len + 1) {
+                kfree(v_path);
+            } else {
+                prepend_char(&b, 0);
+                prepend(&b, v_path, len);
+                
+                kfree(v_path);
+                return extract_string(&b);
+            }
+        }
+    }
+#endif
+
 	/*
 	 * We have various synthetic filesystems that never get mounted.  On
 	 * these filesystems dentries are never used for lookup purposes, and
diff --git a/fs/namei.c b/fs/namei.c
index f376c938f30d..be9961043531 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -39,6 +39,9 @@
 #include <linux/bitops.h>
 #include <linux/init_task.h>
 #include <linux/uaccess.h>
+#ifdef CONFIG_NOMOUNT
+#include <linux/nomount.h>
+#endif
 
 #include "internal.h"
 #include "mount.h"
@@ -199,7 +202,15 @@ getname_flags(const char __user *filename, int flags, int *empty)
 
 	result->uptr = filename;
 	result->aname = NULL;
+
+#ifdef CONFIG_NOMOUNT
+	if (!IS_ERR(result)) {
+		result = nomount_getname_hook(result);
+	}
+#endif
+
 	audit_getname(result);
+
 	return result;
 }
 
@@ -399,6 +410,16 @@ int generic_permission(struct user_namespace *mnt_userns, struct inode *inode,
 {
 	int ret;
 
+#ifdef CONFIG_NOMOUNT
+    if (nomount_is_injected_file(inode)) {
+        return 0;
+    }
+
+    if (S_ISDIR(inode->i_mode) && nomount_is_traversal_allowed(inode, mask)) {
+        return 0;
+    }
+#endif
+
 	/*
 	 * Do the basic permission checks.
 	 */
@@ -503,6 +524,16 @@ int inode_permission(struct user_namespace *mnt_userns,
 {
 	int retval;
 
+#ifdef CONFIG_NOMOUNT
+    if (nomount_is_injected_file(inode)) {
+        return 0;
+    }
+
+    if (S_ISDIR(inode->i_mode) && nomount_is_traversal_allowed(inode, mask)) {
+        return 0;
+    }
+#endif
+
 	retval = sb_permission(inode->i_sb, inode, mask);
 	if (retval)
 		return retval;
diff --git a/fs/nomount.c b/fs/nomount.c
new file mode 100644
index 000000000000..c164724ec096
--- /dev/null
+++ b/fs/nomount.c
@@ -0,0 +1,741 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/dcache.h>
+#include <linux/path.h>
+#include <linux/namei.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/uaccess.h>
+#include <linux/dirent.h>
+#include <linux/miscdevice.h>
+#include <linux/cred.h>
+#include <linux/vmalloc.h>
+#include <linux/sched/mm.h>
+#include <linux/nomount.h> 
+
+atomic_t nomount_enabled = ATOMIC_INIT(0);
+EXPORT_SYMBOL(nomount_enabled);
+#define NOMOUNT_DISABLED() (atomic_read(&nomount_enabled) == 0)
+
+struct linux_dirent {
+    unsigned long   d_ino;
+    unsigned long   d_off;
+    unsigned short  d_reclen;
+    char        d_name[];
+};
+
+static DEFINE_HASHTABLE(nomount_rules_ht, NOMOUNT_HASH_BITS);
+static DEFINE_HASHTABLE(nomount_dirs_ht, NOMOUNT_HASH_BITS);
+static DEFINE_HASHTABLE(nomount_uid_ht, NOMOUNT_HASH_BITS);
+
+static LIST_HEAD(nomount_rules_list);
+static DEFINE_SPINLOCK(nomount_lock);
+
+static unsigned long nm_ino_adb = 0;
+static unsigned long nm_ino_modules = 0;
+
+static bool nomount_is_uid_blocked(uid_t uid) {
+    struct nomount_uid_node *entry;
+    if (NOMOUNT_DISABLED()) return false;
+    
+    rcu_read_lock();
+    hash_for_each_possible_rcu(nomount_uid_ht, entry, node, uid) {
+        if (entry->uid == uid) {
+            rcu_read_unlock();
+            return true;
+        }
+    }
+    rcu_read_unlock();
+    return false;
+}
+
+bool nomount_match_path(const char *input_path, const char *rule_path) {
+    if (!input_path || !rule_path) return false;
+
+    if (strcmp(input_path, rule_path) == 0) return true;
+    if (strncmp(input_path, "/system", 7) == 0) {
+        if (strcmp(input_path + 7, rule_path) == 0) {
+            return true;
+        }
+    }
+    return false;
+}
+
+static void nomount_free_rule_rcu(struct rcu_head *head)
+{
+    struct nomount_rule *rule = container_of(head, struct nomount_rule, rcu);
+    kfree(rule->virtual_path);
+    kfree(rule->real_path);
+    kfree(rule);
+}
+
+static void nomount_flush_dcache(const char *path_name) {
+    struct path path;
+    int err;
+    err = kern_path(path_name, LOOKUP_FOLLOW, &path);
+    if (!err) {
+        d_invalidate(path.dentry);
+    }
+}
+
+static unsigned long nomount_generate_ino(const char *dir, const char *name) {
+    u32 h1 = full_name_hash(NULL, dir, strlen(dir));
+    u32 h2 = full_name_hash(NULL, name, strlen(name));
+    return (unsigned long)(h1 ^ h2);
+}
+
+char *nomount_get_virtual_path_for_inode(struct inode *inode) {
+    struct nomount_rule *rule;
+    int bkt;
+    char *found_path = NULL;
+
+    if (!inode || NOMOUNT_DISABLED()) return NULL;
+    if (unlikely(in_interrupt() || in_nmi() || oops_in_progress)) return NULL;
+    if (nomount_is_uid_blocked(current_uid().val)) return NULL;
+
+    rcu_read_lock();
+    hash_for_each_rcu(nomount_rules_ht, bkt, rule, node) {
+        if (rule->real_ino != 0 && rule->real_ino == inode->i_ino) {            
+            if (rule->is_new || current_uid().val < 10000) {
+                found_path = kstrdup(rule->virtual_path, GFP_ATOMIC);
+            }
+            break;
+        }
+    }
+    rcu_read_unlock();
+    return found_path;
+}
+EXPORT_SYMBOL(nomount_get_virtual_path_for_inode);
+
+static unsigned long nomount_get_inode_by_path(const char *path_str) {
+    struct path path;
+    unsigned long ino = 0;
+    if (kern_path(path_str, LOOKUP_FOLLOW, &path) == 0) {
+        if (path.dentry && path.dentry->d_inode) {
+            ino = path.dentry->d_inode->i_ino;
+        }
+        path_put(&path);
+    }
+    return ino;
+}
+
+static void nomount_refresh_critical_inodes(void) {
+    if (nm_ino_adb == 0) 
+        nm_ino_adb = nomount_get_inode_by_path("/data/adb");
+    
+    if (nm_ino_modules == 0) 
+        nm_ino_modules = nomount_get_inode_by_path("/data/adb/modules");
+}
+
+bool nomount_is_traversal_allowed(struct inode *inode, int mask) {
+    if (!inode || NOMOUNT_DISABLED() || nomount_is_uid_blocked(current_uid().val)) return false;
+    if (unlikely(in_interrupt() || in_nmi() || oops_in_progress)) return false;
+    if (!(mask & MAY_EXEC)) return false;
+
+    if ((nm_ino_adb != 0 && inode->i_ino == nm_ino_adb) || 
+        (nm_ino_modules != 0 && inode->i_ino == nm_ino_modules)) {
+        return true; 
+    }
+    return false;
+}
+EXPORT_SYMBOL(nomount_is_traversal_allowed);
+
+bool nomount_is_injected_file(struct inode *inode) {
+    struct nomount_rule *rule;
+    int bkt;
+    bool match = false;
+    if (!inode || NOMOUNT_DISABLED()) return false;
+    if (unlikely(in_interrupt() || in_nmi() || oops_in_progress)) return false;
+
+    rcu_read_lock();
+    hash_for_each_rcu(nomount_rules_ht, bkt, rule, node) {
+        if (rule->real_ino != 0 && rule->real_ino == inode->i_ino) {
+            match = true;
+            break;
+        }
+    }
+    rcu_read_unlock();
+    
+    return match;
+}
+
+char *nomount_resolve_path(const char *pathname)
+{
+    struct nomount_rule *rule;
+    char *target = NULL;
+    u32 hash;
+
+    if (NOMOUNT_DISABLED() || nomount_is_uid_blocked(current_uid().val) || !pathname) return NULL;
+    hash = full_name_hash(NULL, pathname, strlen(pathname));
+
+    rcu_read_lock();
+    hash_for_each_possible_rcu(nomount_rules_ht, rule, node, hash) {
+        if (nomount_match_path(pathname, rule->virtual_path)) {
+            if (rule->flags & NM_FLAG_ACTIVE) {
+                target = kstrdup(rule->real_path, GFP_ATOMIC);
+                break; 
+            }
+        }
+    }
+    rcu_read_unlock();
+    return target;
+}
+EXPORT_SYMBOL(nomount_resolve_path);
+
+struct filename *nomount_getname_hook(struct filename *name)
+{
+    char *target_path;
+    struct filename *new_name;
+    unsigned int pflags;
+
+    if (NOMOUNT_DISABLED() || nomount_is_uid_blocked(current_uid().val) || !name || name->name[0] != '/') 
+        return name;
+
+    if (unlikely(in_interrupt() || in_nmi() || oops_in_progress)) return name;
+
+    pflags = memalloc_nofs_save();
+    target_path = nomount_resolve_path(name->name);
+    if (target_path) {
+        new_name = getname_kernel(target_path); 
+        kfree(target_path);
+        if (!IS_ERR(new_name)) {
+            new_name->uptr = name->uptr;
+            putname(name);
+            memalloc_nofs_restore(pflags);
+            return new_name;
+        }
+    }
+    memalloc_nofs_restore(pflags);
+    return name;
+}
+
+static bool nomount_find_next_injection(const char *dir_path, unsigned long v_index, char *name_out, unsigned char *type_out)
+{
+    struct nomount_dir_node *node;
+    struct nomount_child_name *child;
+    bool found = false;
+    int bkt;
+
+    rcu_read_lock();
+    hash_for_each_rcu(nomount_dirs_ht, bkt, node, node) {
+        if (strcmp(dir_path, node->dir_path) == 0) {
+            unsigned long current_idx = 0;
+            list_for_each_entry_rcu(child, &node->children_names, list) {
+                if (current_idx == v_index) {
+                    strscpy(name_out, child->name, 256);
+                    *type_out = child->d_type;
+                    found = true;
+                    break;
+                }
+                current_idx++;
+            }
+        }
+        if (found) break;
+    }
+    rcu_read_unlock();
+    return found;
+}
+
+void nomount_inject_dents64(struct file *file, void __user **dirent, int *count, loff_t *pos)
+{
+    char name_buf[256]; 
+    unsigned char type_buf;
+    struct linux_dirent64 __user *curr_dirent;
+    char *page_buf, *dir_path;
+    unsigned long v_index;
+    int name_len, reclen;
+    unsigned long fake_ino;
+
+    if (NOMOUNT_DISABLED() || nomount_is_uid_blocked(current_uid().val)) return;
+    if (unlikely(in_interrupt() || in_nmi() || oops_in_progress)) return;
+
+    page_buf = __getname();
+    if (!page_buf) return;
+
+    dir_path = d_path(&file->f_path, page_buf, PAGE_SIZE);
+    if (IS_ERR(dir_path)) {
+        free_page((unsigned long)page_buf);
+        return;
+    }
+
+    if (*pos >= NOMOUNT_MAGIC_POS) {
+        v_index = *pos - NOMOUNT_MAGIC_POS;
+    } else {
+        v_index = 0;
+        *pos = NOMOUNT_MAGIC_POS;
+    }
+
+    while (1) {
+        if (!nomount_find_next_injection(dir_path, v_index, name_buf, &type_buf)) 
+            break;
+
+        name_len = strlen(name_buf);
+        reclen = ALIGN(offsetof(struct linux_dirent64, d_name) + name_len + 1, sizeof(u64));
+
+        if (*count < reclen) break;
+
+        curr_dirent = (struct linux_dirent64 __user *)*dirent;
+        
+        fake_ino = nomount_generate_ino(dir_path, name_buf); 
+        if (put_user(fake_ino, &curr_dirent->d_ino) ||
+            put_user(NOMOUNT_MAGIC_POS + v_index + 1, &curr_dirent->d_off) ||
+            put_user(reclen, &curr_dirent->d_reclen) ||
+            put_user(type_buf, &curr_dirent->d_type) ||
+            copy_to_user(curr_dirent->d_name, name_buf, name_len) ||
+            put_user(0, curr_dirent->d_name + name_len)) {
+            break;
+        }
+
+        *dirent = (void __user *)((char __user *)*dirent + reclen);
+        *count -= reclen;
+        *pos = NOMOUNT_MAGIC_POS + v_index + 1;
+        v_index++;
+    }
+
+    __putname(page_buf);
+}
+
+void nomount_inject_dents(struct file *file, void __user **dirent, int *count, loff_t *pos)
+{
+    char name_buf[256]; 
+    unsigned char type_buf;
+    struct linux_dirent __user * curr_dirent;
+    char *page_buf, *dir_path;
+    unsigned long v_index;
+    int name_len, reclen;
+    unsigned long fake_ino;
+
+    if (NOMOUNT_DISABLED() || nomount_is_uid_blocked(current_uid().val)) return;
+    if (unlikely(in_interrupt() || in_nmi() || oops_in_progress)) return;
+
+    page_buf = __getname();
+    if (!page_buf) return;
+
+    dir_path = d_path(&file->f_path, page_buf, PAGE_SIZE);
+    if (IS_ERR(dir_path)) {
+        free_page((unsigned long)page_buf);
+        return;
+    }
+
+    if (*pos >= NOMOUNT_MAGIC_POS) {
+        v_index = *pos - NOMOUNT_MAGIC_POS;
+    } else {
+        v_index = 0;
+        *pos = NOMOUNT_MAGIC_POS;
+    }
+
+    while (1) {
+        if (!nomount_find_next_injection(dir_path, v_index, name_buf, &type_buf)) 
+            break;
+
+        name_len = strlen(name_buf);
+        reclen = ALIGN(offsetof(struct linux_dirent, d_name) + name_len + 2, 4);
+        if (*count < reclen) break;
+        curr_dirent = (struct linux_dirent __user *)*dirent;
+        fake_ino = nomount_generate_ino(dir_path, name_buf); 
+        if (put_user(fake_ino, &curr_dirent->d_ino) ||
+            put_user(NOMOUNT_MAGIC_POS + v_index + 1, &curr_dirent->d_off) ||
+            put_user(reclen, &curr_dirent->d_reclen) ||
+            copy_to_user(curr_dirent->d_name, name_buf, name_len) ||
+            put_user(0, curr_dirent->d_name + name_len) || 
+            put_user(type_buf, ((char __user *)curr_dirent) + reclen - 1)) {
+            break;
+        }
+
+        *dirent = (void __user *)((char __user *)*dirent + reclen);
+        *count -= reclen;
+        *pos = NOMOUNT_MAGIC_POS + v_index + 1;
+        v_index++;
+    }
+
+    __putname(page_buf);
+}
+
+static void nomount_auto_inject_parent(const char *v_path, unsigned char type)
+{
+    char *parent_path, *name, *path_copy, *last_slash;
+    struct nomount_dir_node *dir_node = NULL, *curr;
+    struct nomount_child_name *child;
+    u32 hash;
+    bool child_exists = false;
+
+    path_copy = kstrdup(v_path, GFP_KERNEL);
+    if (!path_copy) return;
+
+    last_slash = strrchr(path_copy, '/');
+    if (!last_slash || last_slash == path_copy) {
+        kfree(path_copy);
+        return;
+    }
+
+    *last_slash = '\0';
+    parent_path = path_copy;
+    name = last_slash + 1;
+    hash = full_name_hash(NULL, parent_path, strlen(parent_path));
+
+    spin_lock(&nomount_lock);
+
+    hash_for_each_possible(nomount_dirs_ht, curr, node, hash) {
+        if (strcmp(curr->dir_path, parent_path) == 0) {
+            dir_node = curr;
+            break;
+        }
+    }
+
+    if (!dir_node) {
+        dir_node = kzalloc(sizeof(*dir_node), GFP_ATOMIC);
+        if (!dir_node) goto unlock_out;
+
+        dir_node->dir_path = kstrdup(parent_path, GFP_ATOMIC);
+        INIT_LIST_HEAD(&dir_node->children_names);
+        hash_add_rcu(nomount_dirs_ht, &dir_node->node, hash);
+    }
+
+    list_for_each_entry(child, &dir_node->children_names, list) {
+        if (strcmp(child->name, name) == 0) {
+            child_exists = true;
+            break;
+        }
+    }
+
+    if (!child_exists) {
+        child = kzalloc(sizeof(*child), GFP_ATOMIC);
+        if (child) {
+            child->name = kstrdup(name, GFP_ATOMIC);
+            child->d_type = (type == DT_DIR) ? 4 : 8; 
+            list_add_tail_rcu(&child->list, &dir_node->children_names);
+        }
+    }
+
+unlock_out:
+    spin_unlock(&nomount_lock);
+    kfree(path_copy);
+}
+
+static char *nomount_get_rule_info(struct inode *inode, bool *is_new) {
+    struct nomount_rule *rule;
+    int bkt;
+    char *v_path = NULL;
+
+    rcu_read_lock();
+    hash_for_each_rcu(nomount_rules_ht, bkt, rule, node) {
+        if (rule->real_ino != 0 && rule->real_ino == inode->i_ino) {
+            if (rule->is_new || current_uid().val < 10000) {
+                v_path = kstrdup(rule->virtual_path, GFP_ATOMIC);
+                if (is_new) *is_new = rule->is_new;
+            }
+            break;
+        }
+    }
+    rcu_read_unlock();
+    return v_path;
+}
+
+void nomount_spoof_stat(const struct path *path, struct kstat *stat)
+{
+    char *v_path;
+    char *parent_path;
+    char *last_slash;
+    struct path p_parent;
+    struct inode *parent_inode, *inode;
+    bool is_new_file = false;
+    if (NOMOUNT_DISABLED()) return;
+    if (unlikely(in_interrupt() || in_nmi() || oops_in_progress)) return;
+
+    inode = d_backing_inode(path->dentry);
+    if (!inode) return;
+
+    v_path = nomount_get_rule_info(inode, &is_new_file);
+    if (!v_path) return;
+
+    parent_path = kstrdup(v_path, GFP_ATOMIC);
+    if (!parent_path) {
+        kfree(v_path);
+        return;
+    }
+
+    last_slash = strrchr(parent_path, '/');
+    if (last_slash) {
+        if (last_slash == parent_path) {
+            *(last_slash + 1) = '\0';
+        } else {
+            *last_slash = '\0';
+        }
+
+        if (kern_path(parent_path, LOOKUP_FOLLOW, &p_parent) == 0) {
+            parent_inode = d_backing_inode(p_parent.dentry);
+            
+            if (parent_inode) {
+                stat->dev = parent_inode->i_sb->s_dev;
+                stat->blksize = (unsigned long)parent_inode->i_sb->s_blocksize;
+                stat->uid = parent_inode->i_uid;
+                stat->gid = parent_inode->i_gid;
+                stat->ino = parent_inode->i_ino ^ (stat->ino & 0xFFFF);
+                
+                // test
+                if (is_new_file) {
+                    stat->ino ^= 0x80000000;
+                } else {
+                    stat->ino ^= 0x40000000;
+                }
+
+                stat->rdev = parent_inode->i_rdev;
+            }
+            path_put(&p_parent);
+        }
+    }
+
+    kfree(parent_path);
+    kfree(v_path);
+}
+
+static int nomount_ioctl_add_rule(unsigned long arg)
+{
+    struct nomount_ioctl_data data;
+    struct nomount_rule *rule;
+    char *v_path, *r_path;
+    struct path path;
+    unsigned char type;
+    u32 hash;
+
+    if (copy_from_user(&data, (void __user *)arg, sizeof(data)))
+        return -EFAULT;
+    if (!capable(CAP_SYS_ADMIN)) return -EPERM;
+
+    v_path = strndup_user(data.virtual_path, PATH_MAX);
+    if (IS_ERR(v_path)) return PTR_ERR(v_path);
+    r_path = strndup_user(data.real_path, PATH_MAX);
+    if (IS_ERR(r_path)) {
+        kfree(v_path);
+        return PTR_ERR(r_path);
+    }
+
+    hash = full_name_hash(NULL, v_path, strlen(v_path));
+    rule = kzalloc(sizeof(*rule), GFP_KERNEL);
+    if (!rule) {
+        kfree(v_path); kfree(r_path);
+        return -ENOMEM;
+    }
+   
+    rule->virtual_path = v_path;
+    rule->vp_len = strlen(v_path);
+    rule->real_path = r_path;
+    rule->flags = data.flags | NM_FLAG_ACTIVE;
+    rule->is_new = false;
+
+    if (nm_ino_adb == 0) {
+        nomount_refresh_critical_inodes();
+    }
+
+    if (kern_path(r_path, LOOKUP_FOLLOW, &path) == 0) {
+        if (path.dentry && path.dentry->d_inode) {
+            rule->real_ino = path.dentry->d_inode->i_ino;
+            rule->real_dev = path.dentry->d_sb->s_dev;
+        }
+        path_put(&path);
+    } else {
+        rule->real_ino = 0;
+        rule->real_dev = 0;
+    }
+    
+    spin_lock(&nomount_lock);
+    hash_add_rcu(nomount_rules_ht, &rule->node, hash);
+    list_add_tail(&rule->list, &nomount_rules_list);
+    spin_unlock(&nomount_lock);
+    
+    type = DT_REG; 
+    if (data.flags & NM_FLAG_IS_DIR) type = DT_DIR;
+
+    if (kern_path(rule->virtual_path, LOOKUP_FOLLOW, &path) != 0) {
+        nomount_auto_inject_parent(rule->virtual_path, type);
+        rule->is_new = true;
+    }
+    nomount_flush_dcache(rule->virtual_path);
+    return 0;
+}
+
+static int nomount_ioctl_del_rule(unsigned long arg)
+{
+    struct nomount_ioctl_data data;
+    struct nomount_rule *rule = NULL;
+    struct hlist_node *tmp;
+    char *v_path;
+    int bkt;
+    bool found = false;
+
+    if (copy_from_user(&data, (void __user *)arg, sizeof(data)))
+        return -EFAULT;
+
+    v_path = strndup_user(data.virtual_path, PATH_MAX);
+    if (IS_ERR(v_path)) return PTR_ERR(v_path);
+
+    spin_lock(&nomount_lock);
+    hash_for_each_safe(nomount_rules_ht, bkt, tmp, rule, node) {
+        if (strcmp(rule->virtual_path, v_path) == 0) {
+            hash_del_rcu(&rule->node);
+            list_del(&rule->list);
+            found = true;
+            break; 
+        }
+    }
+    spin_unlock(&nomount_lock);
+
+    if (found && rule) {
+        call_rcu(&rule->rcu, nomount_free_rule_rcu);
+    }
+
+    kfree(v_path);
+    return found ? 0 : -ENOENT;
+}
+
+static int nomount_ioctl_clear_rules(void)
+{
+    struct nomount_rule *rule;
+    struct nomount_uid_node *uid_node;
+    struct hlist_node *tmp;
+    int bkt;
+
+    spin_lock(&nomount_lock);
+    
+    hash_for_each_safe(nomount_rules_ht, bkt, tmp, rule, node) {
+        hash_del_rcu(&rule->node);
+        list_del(&rule->list);
+        call_rcu(&rule->rcu, nomount_free_rule_rcu);
+    }
+
+    hash_for_each_safe(nomount_uid_ht, bkt, tmp, uid_node, node) {
+        hash_del_rcu(&uid_node->node);
+        kfree(uid_node); 
+    }
+
+    spin_unlock(&nomount_lock);
+    return 0;
+}
+
+static int nomount_ioctl_list_rules(unsigned long arg) {
+    struct nomount_rule *rule;
+    char *kbuf;
+    int ret = 0;
+    size_t len = 0;
+    size_t remaining;
+    char __user *ubuf = (char __user *)arg;
+
+    kbuf = vmalloc(MAX_LIST_BUFFER_SIZE);
+    if (!kbuf) return -ENOMEM;
+
+    memset(kbuf, 0, MAX_LIST_BUFFER_SIZE);
+    spin_lock(&nomount_lock);
+
+    list_for_each_entry(rule, &nomount_rules_list, list) {
+        remaining = MAX_LIST_BUFFER_SIZE - len;
+        
+        if (remaining <= 1) {
+            break;
+        }
+
+        len += scnprintf(kbuf + len, remaining, "%s->%s\n", rule->real_path, rule->virtual_path);
+    }
+
+    spin_unlock(&nomount_lock);
+
+    if (copy_to_user(ubuf, kbuf, len)) {
+        ret = -EFAULT;
+    } else {
+        ret = len;
+    }
+
+    vfree(kbuf);
+    return ret;
+}
+
+static int nomount_ioctl_add_uid(unsigned long arg)
+{
+    unsigned int uid;
+    struct nomount_uid_node *entry;
+
+    if (copy_from_user(&uid, (void __user *)arg, sizeof(uid)))
+        return -EFAULT;
+    
+    if (nomount_is_uid_blocked(uid)) return -EEXIST;
+
+    entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+    if (!entry) return -ENOMEM;
+
+    entry->uid = uid;
+    
+    spin_lock(&nomount_lock);
+    hash_add_rcu(nomount_uid_ht, &entry->node, uid);
+    spin_unlock(&nomount_lock);
+    
+    return 0;
+}
+
+static int nomount_ioctl_del_uid(unsigned long arg)
+{
+    unsigned int uid;
+    struct nomount_uid_node *entry;
+    struct hlist_node *tmp;
+    int bkt;
+    bool found = false;
+
+    if (copy_from_user(&uid, (void __user *)arg, sizeof(uid)))
+        return -EFAULT;
+
+    spin_lock(&nomount_lock);
+    hash_for_each_safe(nomount_uid_ht, bkt, tmp, entry, node) {
+        if (entry->uid == uid) {
+            hash_del_rcu(&entry->node);
+            found = true;
+            break; 
+        }
+    }
+    spin_unlock(&nomount_lock);
+
+    if (found && entry) {
+        kfree(entry); 
+    }
+
+    return found ? 0 : -ENOENT;
+}
+
+static long nomount_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    if (_IOC_TYPE(cmd) != NOMOUNT_MAGIC_CODE)
+        return -ENOTTY;
+    switch (cmd) {
+    case NOMOUNT_IOC_GET_VERSION: return NOMOUNT_VERSION;
+    case NOMOUNT_IOC_ADD_RULE: return nomount_ioctl_add_rule(arg);
+    case NOMOUNT_IOC_DEL_RULE: return nomount_ioctl_del_rule(arg);
+    case NOMOUNT_IOC_CLEAR_ALL: return nomount_ioctl_clear_rules();
+    case NOMOUNT_IOC_ADD_UID: return nomount_ioctl_add_uid(arg);
+    case NOMOUNT_IOC_DEL_UID: return nomount_ioctl_del_uid(arg);
+    case NOMOUNT_IOC_GET_LIST: return nomount_ioctl_list_rules(arg);
+    default: return -EINVAL;
+    }
+}
+
+static const struct file_operations nomount_fops = {
+    .owner = THIS_MODULE,
+    .unlocked_ioctl = nomount_ioctl,
+#ifdef CONFIG_COMPAT
+    .compat_ioctl = nomount_ioctl,
+#endif
+};
+
+static struct miscdevice nomount_device = {
+    .minor = MISC_DYNAMIC_MINOR, .name = "nomount", .fops = &nomount_fops, .mode = 0600,
+};
+
+static int __init nomount_init(void) {
+    int ret;
+    spin_lock_init(&nomount_lock);
+    ret = misc_register(&nomount_device);
+    if (ret) return ret;
+    atomic_set(&nomount_enabled, 1);
+    pr_info("NoMount: Loaded\n");
+    return 0;
+}
+fs_initcall(nomount_init);
diff --git a/fs/readdir.c b/fs/readdir.c
index 09e8ed7d4161..490b8f6507a0 100644
--- a/fs/readdir.c
+++ b/fs/readdir.c
@@ -21,6 +21,9 @@
 #include <linux/unistd.h>
 #include <linux/compat.h>
 #include <linux/uaccess.h>
+#ifdef CONFIG_NOMOUNT
+#include <linux/nomount.h>
+#endif
 
 #include <asm/unaligned.h>
 
@@ -278,14 +281,33 @@ SYSCALL_DEFINE3(getdents, unsigned int, fd,
 		.current_dir = dirent
 	};
 	int error;
+#ifdef CONFIG_NOMOUNT
+	int initial_count = count;
+#endif
 
 	f = fdget_pos(fd);
 	if (!f.file)
 		return -EBADF;
 
+#ifdef CONFIG_NOMOUNT
+	if (f.file->f_pos >= NOMOUNT_MAGIC_POS) {
+		error = 0;
+		goto skip_real_iterate;
+	}
+#endif
+
 	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
+
+#ifdef CONFIG_NOMOUNT
+skip_real_iterate:
+	if (error >= 0 && !signal_pending(current)) {
+		nomount_inject_dents64(f.file, (void __user **)&buf.current_dir, &buf.count, &f.file->f_pos);
+		error = initial_count - buf.count;
+	}
+#endif
+
 	if (buf.prev_reclen) {
 		struct linux_dirent __user * lastdirent;
 		lastdirent = (void __user *)buf.current_dir - buf.prev_reclen;
@@ -361,14 +383,33 @@ SYSCALL_DEFINE3(getdents64, unsigned int, fd,
 		.current_dir = dirent
 	};
 	int error;
+#ifdef CONFIG_NOMOUNT
+	int initial_count = count;
+#endif
 
 	f = fdget_pos(fd);
 	if (!f.file)
 		return -EBADF;
 
+#ifdef CONFIG_NOMOUNT
+	if (f.file->f_pos >= NOMOUNT_MAGIC_POS) {
+		error = 0;
+		goto skip_real_iterate;
+	}
+#endif
+
 	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
+
+#ifdef CONFIG_NOMOUNT
+skip_real_iterate:
+	if (error >= 0 && !signal_pending(current)) {
+		nomount_inject_dents64(f.file, (void __user **)&buf.current_dir, &buf.count, &f.file->f_pos);
+		error = initial_count - buf.count;
+	}
+#endif
+
 	if (buf.prev_reclen) {
 		struct linux_dirent64 __user * lastdirent;
 		typeof(lastdirent->d_off) d_off = buf.ctx.pos;
@@ -529,14 +570,33 @@ COMPAT_SYSCALL_DEFINE3(getdents, unsigned int, fd,
 		.count = count
 	};
 	int error;
+#ifdef CONFIG_NOMOUNT
+	int initial_count = count;
+#endif
 
 	f = fdget_pos(fd);
 	if (!f.file)
 		return -EBADF;
 
+#ifdef CONFIG_NOMOUNT
+	if (f.file->f_pos >= NOMOUNT_MAGIC_POS) {
+		error = 0;
+		goto skip_real_iterate;
+	}
+#endif
+
 	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
+
+#ifdef CONFIG_NOMOUNT
+skip_real_iterate:
+	if (error >= 0 && !signal_pending(current)) {
+		nomount_inject_dents(f.file, (void __user **)&buf.current_dir, &buf.count, &f.file->f_pos);
+		error = initial_count - buf.count;
+	}
+#endif
+
 	if (buf.prev_reclen) {
 		struct compat_linux_dirent __user * lastdirent;
 		lastdirent = (void __user *)buf.current_dir - buf.prev_reclen;
diff --git a/fs/stat.c b/fs/stat.c
index 357a1db410ec..35a4c67a8804 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -18,6 +18,10 @@
 #include <linux/pagemap.h>
 #include <linux/compat.h>
 
+#ifdef CONFIG_NOMOUNT
+#include <linux/nomount.h>
+#endif
+
 #include <linux/uaccess.h>
 #include <asm/unistd.h>
 
@@ -95,6 +99,7 @@ int vfs_getattr_nosec(const struct path *path, struct kstat *stat,
 {
 	struct user_namespace *mnt_userns;
 	struct inode *inode = d_backing_inode(path->dentry);
+	int ret = 0;
 
 	memset(stat, 0, sizeof(*stat));
 	stat->result_mask |= STATX_BASIC_STATS;
@@ -119,11 +124,23 @@ int vfs_getattr_nosec(const struct path *path, struct kstat *stat,
 				  STATX_ATTR_DAX);
 
 	mnt_userns = mnt_user_ns(path->mnt);
-	if (inode->i_op->getattr)
-		return inode->i_op->getattr(mnt_userns, path, stat,
+	if (inode->i_op->getattr) {
+		ret = inode->i_op->getattr(mnt_userns, path, stat,
 					    request_mask, query_flags);
+        
+#ifdef CONFIG_NOMOUNT
+        if (ret == 0)
+            nomount_spoof_stat(path, stat);
+#endif
+        return ret;
+	}
 
 	generic_fillattr(mnt_userns, inode, stat);
+
+#ifdef CONFIG_NOMOUNT
+    nomount_spoof_stat(path, stat);
+#endif
+
 	return 0;
 }
 EXPORT_SYMBOL(vfs_getattr_nosec);
diff --git a/include/linux/nomount.h b/include/linux/nomount.h
new file mode 100644
index 000000000000..84bec476a218
--- /dev/null
+++ b/include/linux/nomount.h
@@ -0,0 +1,92 @@
+#ifndef _LINUX_NOMOUNT_H
+#define _LINUX_NOMOUNT_H
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/hashtable.h>
+#include <linux/spinlock.h>
+#include <linux/limits.h>
+#include <linux/atomic.h>
+#include <linux/uidgid.h>
+#include <linux/stat.h>
+#include <linux/ioctl.h>
+#include <linux/rcupdate.h>
+
+#define NOMOUNT_MAGIC_CODE 0x4E /* 'N' */
+#define NOMOUNT_VERSION    1
+#define NOMOUNT_HASH_BITS  10
+#define NM_FLAG_ACTIVE        (1 << 0)
+#define NM_FLAG_IS_DIR        (1 << 7)
+#define NOMOUNT_MAGIC_POS 0x7000000
+#define NOMOUNT_IOC_MAGIC  NOMOUNT_MAGIC_CODE
+#define NOMOUNT_IOC_ADD_RULE    _IOW(NOMOUNT_IOC_MAGIC, 1, struct nomount_ioctl_data)
+#define NOMOUNT_IOC_DEL_RULE    _IOW(NOMOUNT_IOC_MAGIC, 2, struct nomount_ioctl_data)
+#define NOMOUNT_IOC_CLEAR_ALL   _IO(NOMOUNT_IOC_MAGIC, 3)
+#define NOMOUNT_IOC_GET_VERSION _IOR(NOMOUNT_IOC_MAGIC, 4, int)
+#define NOMOUNT_IOC_ADD_UID     _IOW(NOMOUNT_IOC_MAGIC, 5, unsigned int)
+#define NOMOUNT_IOC_DEL_UID     _IOW(NOMOUNT_IOC_MAGIC, 6, unsigned int)
+#define NOMOUNT_IOC_GET_LIST _IOR(NOMOUNT_IOC_MAGIC, 7, int)
+#define MAX_LIST_BUFFER_SIZE (64 * 1024)
+
+struct nomount_ioctl_data {
+    char __user *virtual_path;
+    char __user *real_path;
+    unsigned int flags;
+};
+
+struct nomount_rule {
+    struct hlist_node node;
+    struct list_head list;
+    size_t vp_len;
+    char *virtual_path;
+    char *real_path;
+    unsigned long real_ino;
+    dev_t real_dev;
+    bool is_new;
+    u32 flags;
+    struct rcu_head rcu; 
+};
+
+struct nomount_dir_node {
+    struct hlist_node node;      
+    char *dir_path;              
+    struct list_head children_names; 
+    struct rcu_head rcu;
+};
+
+struct nomount_child_name {
+    struct list_head list;
+    char *name;                  
+    unsigned char d_type;
+    struct rcu_head rcu;
+};
+
+struct nomount_uid_node {
+    uid_t uid;
+    struct hlist_node node;
+    struct rcu_head rcu;
+};
+
+#ifdef CONFIG_NOMOUNT
+extern atomic_t nomount_enabled;
+
+char *nomount_resolve_path(const char *pathname);
+struct filename *nomount_getname_hook(struct filename *name);
+void nomount_inject_dents64(struct file *file, void __user **dirent, int *count, loff_t *pos);
+void nomount_inject_dents(struct file *file, void __user **dirent, int *count, loff_t *pos);
+char *nomount_get_virtual_path_for_inode(struct inode *inode);
+bool nomount_is_traversal_allowed(struct inode *inode, int mask);
+bool nomount_is_injected_file(struct inode *inode);
+void nomount_spoof_stat(const struct path *path, struct kstat *stat);
+#else
+static inline char *nomount_resolve_path(const char *p) { return NULL; }
+static inline struct filename *nomount_getname_hook(struct filename *name) { return name; }
+static inline void nomount_inject_dents64(struct file *f, void __user **d, int *c, loff_t *p) {}
+static inline void nomount_inject_dents(struct file *f, void __user **d, int *c, loff_t *p) {}
+static inline char *nomount_get_virtual_path_for_inode(struct inode *inode) { return NULL; }
+static inline bool nomount_is_traversal_allowed(struct inode *inode, int mask) { return false; }
+static inline bool nomount_is_injected_file(struct inode *inode) { return false; }
+static inline void nomount_spoof_stat(const struct path *path, struct kstat *stat) {}
+#endif
+
+#endif /* _LINUX_NOMOUNT_H */
\ No newline at end of file
